<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>picklecryptor.picklecryptor API documentation</title>
<meta name="description" content="The main implementation file for PickleCryptor" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>picklecryptor.picklecryptor</code></h1>
</header>
<section id="section-intro">
<p>The main implementation file for PickleCryptor</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
The main implementation file for PickleCryptor
&#39;&#39;&#39;

import base64
import enum
import pickle
import typing
import zlib

from Crypto.Cipher import AES, Salsa20
from Crypto.Util.Padding import pad, unpad

class EncryptionType(enum.Enum):
    &#39;&#39;&#39; Enum representing the types of encryption PickleCryptor can perform &#39;&#39;&#39;
    NONE = enum.auto() #: Use no encryption
    AES_ECB = enum.auto()
    SALSA_20 = enum.auto()

class CompressionType(enum.Enum):
    &#39;&#39;&#39; Enum representing the types of compression PickleCryptor can perform &#39;&#39;&#39;
    NONE = enum.auto()
    ZLIB_DEFAULT = enum.auto()
    ZLIB_BEST_SPEED = enum.auto()
    ZLIB_BEST_COMPRESSION = enum.auto()
    ZLIB_NO_COMPRESSION = enum.auto()

def _repeat_to_length(string_to_expand: typing.Union[bytes, str], length:int) -&gt; typing.Union[bytes, str]:
    &#39;&#39;&#39; Repeats the given string to get to the given length &#39;&#39;&#39;
    return (string_to_expand * (int(length / len(string_to_expand)) + 1))[:length]

class PickleCryptor:
    def __init__(self,
                 password:str=&#39;&#39;,
                 encryption:EncryptionType=EncryptionType.AES_ECB,
                 compression:CompressionType=CompressionType.ZLIB_DEFAULT,
                 pickle_module=pickle):
        &#39;&#39;&#39;
        Creates an object that can be used to serialize/deserialize python objects.
            When serializing/unserializting the given encryption and compression will be
            used along with the given pickle_module and password.

        Arguments:
            password: A key to use to encrypt/decrypt the data
            encryption: A member of EncryptionType denoting what type of encryption to perform
            compression: A member of CompressionType denoting what type of compression to perform
            pickle_module: The serialization module to use. Must have .dumps and .loads methods similar to pickle.
        &#39;&#39;&#39;

        if len(password) &lt; 1 and self._encryption != EncryptionType.NONE:
            raise ValueError(&#34;Password should be longer than empty for encryption.&#34;)

        # if password is not divisible by block size, lengthen to fill the next block
        password = password.encode()

        self._password = password
        self._encryption = encryption
        self._pickle_module = pickle_module
        self._compression = compression

        encryption_module = None
        if self._encryption == EncryptionType.AES_ECB:
            encryption_module = AES
        elif self._encryption == EncryptionType.SALSA_20:
            encryption_module = Salsa20

        if encryption_module:
            for possible_block_size in [k for k in getattr(encryption_module, &#39;key_size&#39;) if k % getattr(encryption_module, &#39;block_size&#39;, 1) == 0]:
                if len(self._password) &lt;= possible_block_size:
                    self._encryption_block_size = possible_block_size
                    self._password = _repeat_to_length(self._password, self._encryption_block_size)
                    break
            else:
                raise ValueError(f&#34;For {encryption.name} encryption, the password was too long. It could not fit in a supported key size. Max key size: {max(AES.key_size)}. It&#39;s size was: {len(self._password)}.&#34;)

        # this must be done after self._password is fully setup
        if self._encryption == EncryptionType.AES_ECB:
            self._aes = AES.new(self._password, AES.MODE_ECB)

    def _ensure_is_bytes(self, data:bytes) -&gt; None:
        &#39;&#39;&#39; Takes in the given data field and with raise TypeError if it is not a bytes object &#39;&#39;&#39;
        if not isinstance(data, bytes):
            raise TypeError(f&#34;data should be of type bytes. It is of type: {type(data)}&#34;)

    def _encrypt(self, data:bytes) -&gt; bytes:
        &#39;&#39;&#39;
            Returns the encrypted version of the data. See _decrypt() for the other direction.
            Uses the originally given encryption type and password.
        &#39;&#39;&#39;
        self._ensure_is_bytes(data)

        if self._encryption == EncryptionType.NONE:
            pass
        elif self._encryption == EncryptionType.AES_ECB:
            data =self._aes.encrypt(pad(data, self._encryption_block_size))
        elif self._encryption == EncryptionType.SALSA_20:
            cipher = Salsa20.new(key=self._password)
            data = cipher.nonce + cipher.encrypt(data)
        else:
            raise ValueError(f&#34;Unsupported encryption type: {self._encryption}&#34;)
        return data

    def _decrypt(self, data:bytes) -&gt; bytes:
        &#39;&#39;&#39;
            Returns the decrypted version of the data. See _encrypt() for the other direction.
            Uses the originally given encryption type and password.
        &#39;&#39;&#39;
        self._ensure_is_bytes(data)

        if self._encryption == EncryptionType.NONE:
            pass
        elif self._encryption == EncryptionType.AES_ECB:
            data = unpad(self._aes.decrypt(data), self._encryption_block_size)
        elif self._encryption == EncryptionType.SALSA_20:
            nonce = data[:8]
            secret = data[8:]
            data = Salsa20.new(self._password, nonce).decrypt(secret)
        else:
            raise ValueError(f&#34;Unsupported encryption type: {self._encryption}&#34;)
        return data

    def _compress(self, data:bytes) -&gt; bytes:
        &#39;&#39;&#39;
            Returns the compressed version of the data. See _decompress() for the other direction.
            Uses the originally given compression type.
        &#39;&#39;&#39;
        self._ensure_is_bytes(data)

        if self._compression == CompressionType.NONE:
            pass
        elif self._compression == CompressionType.ZLIB_DEFAULT:
            data = zlib.compress(data, zlib.Z_DEFAULT_COMPRESSION)
        elif self._compression == CompressionType.ZLIB_BEST_SPEED:
            data = zlib.compress(data, zlib.Z_BEST_SPEED)
        elif self._compression == CompressionType.ZLIB_BEST_COMPRESSION:
            data = zlib.compress(data, zlib.Z_BEST_COMPRESSION)
        elif self._compression == CompressionType.ZLIB_NO_COMPRESSION:
            data = zlib.compress(data, zlib.Z_NO_COMPRESSION)
        else:
            raise ValueError(f&#34;Unsupported compression type: {self._compression}&#34;)

        return data

    def _decompress(self, data:bytes) -&gt; bytes:
        &#39;&#39;&#39;
            Returns the uncompressed version of the data. See _compress() for the other direction.
            Uses the originally given compression type.
        &#39;&#39;&#39;
        self._ensure_is_bytes(data)

        if self._compression == CompressionType.NONE:
            pass
        elif self._compression in (CompressionType.ZLIB_DEFAULT,
                                   CompressionType.ZLIB_BEST_SPEED,
                                   CompressionType.ZLIB_BEST_COMPRESSION,
                                   CompressionType.ZLIB_NO_COMPRESSION):
            data = zlib.decompress(data)
        else:
            raise ValueError(f&#34;Unsupported compression type: {self._compression}&#34;)

        return data

    def serialize(self, obj:typing.Any) -&gt; bytes:
        &#39;&#39;&#39;
        Takes the given object, serializes it using the given pickle module.
            Then compresses it using the given compression type.
            Then encrypts it using the given encryption type.
            Returns the encrypted/compressed/serialized data.
        &#39;&#39;&#39;
        pickle_data = self._pickle_module.dumps(obj)
        compressed_data = self._compress(pickle_data)
        encrypted_data = self._encrypt(compressed_data)
        return encrypted_data

    def deserialize(self, data:bytes) -&gt; typing.Any:
        &#39;&#39;&#39;
        Takes the given data, decrypts it using the given encryption type.
            Then uncompresses it using the given compression type.
            Then deserializes it using the given pickle module.
            Returns the final object.
        &#39;&#39;&#39;
        self._ensure_is_bytes(data)

        decrypted_data = self._decrypt(data)
        uncompressed_data = self._decompress(decrypted_data)
        obj = self._pickle_module.loads(uncompressed_data)
        return obj

if __name__ == &#39;__main__&#39;:
    p = PickleCryptor(&#39;test123&#39;, EncryptionType.SALSA_20, CompressionType.ZLIB_BEST_COMPRESSION)
    self = p</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="picklecryptor.picklecryptor.CompressionType"><code class="flex name class">
<span>class <span class="ident">CompressionType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum representing the types of compression PickleCryptor can perform</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompressionType(enum.Enum):
    &#39;&#39;&#39; Enum representing the types of compression PickleCryptor can perform &#39;&#39;&#39;
    NONE = enum.auto()
    ZLIB_DEFAULT = enum.auto()
    ZLIB_BEST_SPEED = enum.auto()
    ZLIB_BEST_COMPRESSION = enum.auto()
    ZLIB_NO_COMPRESSION = enum.auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="picklecryptor.picklecryptor.CompressionType.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="picklecryptor.picklecryptor.CompressionType.ZLIB_BEST_COMPRESSION"><code class="name">var <span class="ident">ZLIB_BEST_COMPRESSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="picklecryptor.picklecryptor.CompressionType.ZLIB_BEST_SPEED"><code class="name">var <span class="ident">ZLIB_BEST_SPEED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="picklecryptor.picklecryptor.CompressionType.ZLIB_DEFAULT"><code class="name">var <span class="ident">ZLIB_DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="picklecryptor.picklecryptor.CompressionType.ZLIB_NO_COMPRESSION"><code class="name">var <span class="ident">ZLIB_NO_COMPRESSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="picklecryptor.picklecryptor.EncryptionType"><code class="flex name class">
<span>class <span class="ident">EncryptionType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum representing the types of encryption PickleCryptor can perform</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EncryptionType(enum.Enum):
    &#39;&#39;&#39; Enum representing the types of encryption PickleCryptor can perform &#39;&#39;&#39;
    NONE = enum.auto() #: Use no encryption
    AES_ECB = enum.auto()
    SALSA_20 = enum.auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="picklecryptor.picklecryptor.EncryptionType.AES_ECB"><code class="name">var <span class="ident">AES_ECB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="picklecryptor.picklecryptor.EncryptionType.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="picklecryptor.picklecryptor.EncryptionType.SALSA_20"><code class="name">var <span class="ident">SALSA_20</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="picklecryptor.picklecryptor.PickleCryptor"><code class="flex name class">
<span>class <span class="ident">PickleCryptor</span></span>
<span>(</span><span>password: str = '', encryption: <a title="picklecryptor.picklecryptor.EncryptionType" href="#picklecryptor.picklecryptor.EncryptionType">EncryptionType</a> = EncryptionType.AES_ECB, compression: <a title="picklecryptor.picklecryptor.CompressionType" href="#picklecryptor.picklecryptor.CompressionType">CompressionType</a> = CompressionType.ZLIB_DEFAULT, pickle_module=&lt;module &#x27;pickle&#x27; from &#x27;/opt/hostedtoolcache/Python/3.7.9/x64/lib/python3.7/pickle.py&#x27;&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an object that can be used to serialize/deserialize python objects.
When serializing/unserializting the given encryption and compression will be
used along with the given pickle_module and password.</p>
<h2 id="arguments">Arguments</h2>
<p>password: A key to use to encrypt/decrypt the data
encryption: A member of EncryptionType denoting what type of encryption to perform
compression: A member of CompressionType denoting what type of compression to perform
pickle_module: The serialization module to use. Must have .dumps and .loads methods similar to pickle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PickleCryptor:
    def __init__(self,
                 password:str=&#39;&#39;,
                 encryption:EncryptionType=EncryptionType.AES_ECB,
                 compression:CompressionType=CompressionType.ZLIB_DEFAULT,
                 pickle_module=pickle):
        &#39;&#39;&#39;
        Creates an object that can be used to serialize/deserialize python objects.
            When serializing/unserializting the given encryption and compression will be
            used along with the given pickle_module and password.

        Arguments:
            password: A key to use to encrypt/decrypt the data
            encryption: A member of EncryptionType denoting what type of encryption to perform
            compression: A member of CompressionType denoting what type of compression to perform
            pickle_module: The serialization module to use. Must have .dumps and .loads methods similar to pickle.
        &#39;&#39;&#39;

        if len(password) &lt; 1 and self._encryption != EncryptionType.NONE:
            raise ValueError(&#34;Password should be longer than empty for encryption.&#34;)

        # if password is not divisible by block size, lengthen to fill the next block
        password = password.encode()

        self._password = password
        self._encryption = encryption
        self._pickle_module = pickle_module
        self._compression = compression

        encryption_module = None
        if self._encryption == EncryptionType.AES_ECB:
            encryption_module = AES
        elif self._encryption == EncryptionType.SALSA_20:
            encryption_module = Salsa20

        if encryption_module:
            for possible_block_size in [k for k in getattr(encryption_module, &#39;key_size&#39;) if k % getattr(encryption_module, &#39;block_size&#39;, 1) == 0]:
                if len(self._password) &lt;= possible_block_size:
                    self._encryption_block_size = possible_block_size
                    self._password = _repeat_to_length(self._password, self._encryption_block_size)
                    break
            else:
                raise ValueError(f&#34;For {encryption.name} encryption, the password was too long. It could not fit in a supported key size. Max key size: {max(AES.key_size)}. It&#39;s size was: {len(self._password)}.&#34;)

        # this must be done after self._password is fully setup
        if self._encryption == EncryptionType.AES_ECB:
            self._aes = AES.new(self._password, AES.MODE_ECB)

    def _ensure_is_bytes(self, data:bytes) -&gt; None:
        &#39;&#39;&#39; Takes in the given data field and with raise TypeError if it is not a bytes object &#39;&#39;&#39;
        if not isinstance(data, bytes):
            raise TypeError(f&#34;data should be of type bytes. It is of type: {type(data)}&#34;)

    def _encrypt(self, data:bytes) -&gt; bytes:
        &#39;&#39;&#39;
            Returns the encrypted version of the data. See _decrypt() for the other direction.
            Uses the originally given encryption type and password.
        &#39;&#39;&#39;
        self._ensure_is_bytes(data)

        if self._encryption == EncryptionType.NONE:
            pass
        elif self._encryption == EncryptionType.AES_ECB:
            data =self._aes.encrypt(pad(data, self._encryption_block_size))
        elif self._encryption == EncryptionType.SALSA_20:
            cipher = Salsa20.new(key=self._password)
            data = cipher.nonce + cipher.encrypt(data)
        else:
            raise ValueError(f&#34;Unsupported encryption type: {self._encryption}&#34;)
        return data

    def _decrypt(self, data:bytes) -&gt; bytes:
        &#39;&#39;&#39;
            Returns the decrypted version of the data. See _encrypt() for the other direction.
            Uses the originally given encryption type and password.
        &#39;&#39;&#39;
        self._ensure_is_bytes(data)

        if self._encryption == EncryptionType.NONE:
            pass
        elif self._encryption == EncryptionType.AES_ECB:
            data = unpad(self._aes.decrypt(data), self._encryption_block_size)
        elif self._encryption == EncryptionType.SALSA_20:
            nonce = data[:8]
            secret = data[8:]
            data = Salsa20.new(self._password, nonce).decrypt(secret)
        else:
            raise ValueError(f&#34;Unsupported encryption type: {self._encryption}&#34;)
        return data

    def _compress(self, data:bytes) -&gt; bytes:
        &#39;&#39;&#39;
            Returns the compressed version of the data. See _decompress() for the other direction.
            Uses the originally given compression type.
        &#39;&#39;&#39;
        self._ensure_is_bytes(data)

        if self._compression == CompressionType.NONE:
            pass
        elif self._compression == CompressionType.ZLIB_DEFAULT:
            data = zlib.compress(data, zlib.Z_DEFAULT_COMPRESSION)
        elif self._compression == CompressionType.ZLIB_BEST_SPEED:
            data = zlib.compress(data, zlib.Z_BEST_SPEED)
        elif self._compression == CompressionType.ZLIB_BEST_COMPRESSION:
            data = zlib.compress(data, zlib.Z_BEST_COMPRESSION)
        elif self._compression == CompressionType.ZLIB_NO_COMPRESSION:
            data = zlib.compress(data, zlib.Z_NO_COMPRESSION)
        else:
            raise ValueError(f&#34;Unsupported compression type: {self._compression}&#34;)

        return data

    def _decompress(self, data:bytes) -&gt; bytes:
        &#39;&#39;&#39;
            Returns the uncompressed version of the data. See _compress() for the other direction.
            Uses the originally given compression type.
        &#39;&#39;&#39;
        self._ensure_is_bytes(data)

        if self._compression == CompressionType.NONE:
            pass
        elif self._compression in (CompressionType.ZLIB_DEFAULT,
                                   CompressionType.ZLIB_BEST_SPEED,
                                   CompressionType.ZLIB_BEST_COMPRESSION,
                                   CompressionType.ZLIB_NO_COMPRESSION):
            data = zlib.decompress(data)
        else:
            raise ValueError(f&#34;Unsupported compression type: {self._compression}&#34;)

        return data

    def serialize(self, obj:typing.Any) -&gt; bytes:
        &#39;&#39;&#39;
        Takes the given object, serializes it using the given pickle module.
            Then compresses it using the given compression type.
            Then encrypts it using the given encryption type.
            Returns the encrypted/compressed/serialized data.
        &#39;&#39;&#39;
        pickle_data = self._pickle_module.dumps(obj)
        compressed_data = self._compress(pickle_data)
        encrypted_data = self._encrypt(compressed_data)
        return encrypted_data

    def deserialize(self, data:bytes) -&gt; typing.Any:
        &#39;&#39;&#39;
        Takes the given data, decrypts it using the given encryption type.
            Then uncompresses it using the given compression type.
            Then deserializes it using the given pickle module.
            Returns the final object.
        &#39;&#39;&#39;
        self._ensure_is_bytes(data)

        decrypted_data = self._decrypt(data)
        uncompressed_data = self._decompress(decrypted_data)
        obj = self._pickle_module.loads(uncompressed_data)
        return obj</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="picklecryptor.picklecryptor.PickleCryptor.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>self, data: bytes) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the given data, decrypts it using the given encryption type.
Then uncompresses it using the given compression type.
Then deserializes it using the given pickle module.
Returns the final object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialize(self, data:bytes) -&gt; typing.Any:
    &#39;&#39;&#39;
    Takes the given data, decrypts it using the given encryption type.
        Then uncompresses it using the given compression type.
        Then deserializes it using the given pickle module.
        Returns the final object.
    &#39;&#39;&#39;
    self._ensure_is_bytes(data)

    decrypted_data = self._decrypt(data)
    uncompressed_data = self._decompress(decrypted_data)
    obj = self._pickle_module.loads(uncompressed_data)
    return obj</code></pre>
</details>
</dd>
<dt id="picklecryptor.picklecryptor.PickleCryptor.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj: Any) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the given object, serializes it using the given pickle module.
Then compresses it using the given compression type.
Then encrypts it using the given encryption type.
Returns the encrypted/compressed/serialized data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self, obj:typing.Any) -&gt; bytes:
    &#39;&#39;&#39;
    Takes the given object, serializes it using the given pickle module.
        Then compresses it using the given compression type.
        Then encrypts it using the given encryption type.
        Returns the encrypted/compressed/serialized data.
    &#39;&#39;&#39;
    pickle_data = self._pickle_module.dumps(obj)
    compressed_data = self._compress(pickle_data)
    encrypted_data = self._encrypt(compressed_data)
    return encrypted_data</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="picklecryptor" href="index.html">picklecryptor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="picklecryptor.picklecryptor.CompressionType" href="#picklecryptor.picklecryptor.CompressionType">CompressionType</a></code></h4>
<ul class="">
<li><code><a title="picklecryptor.picklecryptor.CompressionType.NONE" href="#picklecryptor.picklecryptor.CompressionType.NONE">NONE</a></code></li>
<li><code><a title="picklecryptor.picklecryptor.CompressionType.ZLIB_BEST_COMPRESSION" href="#picklecryptor.picklecryptor.CompressionType.ZLIB_BEST_COMPRESSION">ZLIB_BEST_COMPRESSION</a></code></li>
<li><code><a title="picklecryptor.picklecryptor.CompressionType.ZLIB_BEST_SPEED" href="#picklecryptor.picklecryptor.CompressionType.ZLIB_BEST_SPEED">ZLIB_BEST_SPEED</a></code></li>
<li><code><a title="picklecryptor.picklecryptor.CompressionType.ZLIB_DEFAULT" href="#picklecryptor.picklecryptor.CompressionType.ZLIB_DEFAULT">ZLIB_DEFAULT</a></code></li>
<li><code><a title="picklecryptor.picklecryptor.CompressionType.ZLIB_NO_COMPRESSION" href="#picklecryptor.picklecryptor.CompressionType.ZLIB_NO_COMPRESSION">ZLIB_NO_COMPRESSION</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="picklecryptor.picklecryptor.EncryptionType" href="#picklecryptor.picklecryptor.EncryptionType">EncryptionType</a></code></h4>
<ul class="">
<li><code><a title="picklecryptor.picklecryptor.EncryptionType.AES_ECB" href="#picklecryptor.picklecryptor.EncryptionType.AES_ECB">AES_ECB</a></code></li>
<li><code><a title="picklecryptor.picklecryptor.EncryptionType.NONE" href="#picklecryptor.picklecryptor.EncryptionType.NONE">NONE</a></code></li>
<li><code><a title="picklecryptor.picklecryptor.EncryptionType.SALSA_20" href="#picklecryptor.picklecryptor.EncryptionType.SALSA_20">SALSA_20</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="picklecryptor.picklecryptor.PickleCryptor" href="#picklecryptor.picklecryptor.PickleCryptor">PickleCryptor</a></code></h4>
<ul class="">
<li><code><a title="picklecryptor.picklecryptor.PickleCryptor.deserialize" href="#picklecryptor.picklecryptor.PickleCryptor.deserialize">deserialize</a></code></li>
<li><code><a title="picklecryptor.picklecryptor.PickleCryptor.serialize" href="#picklecryptor.picklecryptor.PickleCryptor.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>